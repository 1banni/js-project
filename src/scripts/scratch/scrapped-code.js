


    // let playerDirection = [[0, 0], [0, 0]];
    // let playerBlasters = [false, false];
    // // console.log(this.pressedKeys);
    // if (this.pressedKeys) {
    //   // Player 1 Key Register
    //   if (this.pressedKeys.w) playerDirection[0][1] -= 1;
    //   if (this.pressedKeys.a) playerDirection[0][0] -= 1;
    //   if (this.pressedKeys.s) playerDirection[0][1] += 1;
    //   if (this.pressedKeys.d) playerDirection[0][0] += 1;
    //   if (this.pressedKeys.d) playerDirection[0][0] += 1;
    //   if (this.pressedKeys[' ']) playerBlasters[0] += true;

    //   // Player 2 Key Register
    //   if (this.pressedKeys.ArrowUp) playerDirection[1][1] -= 1;
    //   if (this.pressedKeys.ArrowLeft) playerDirection[1][0] -= 1;
    //   if (this.pressedKeys.ArrowDown) playerDirection[1][1] += 1;
    //   if (this.pressedKeys.ArrowRight) playerDirection[1][0] += 1;
    //   if (this.pressedKeys[0]) playerBlasters[1] += true;
    // }


      // player.setVelocity(playerDirection[idx]);
      // if (playerBlasters[idx]) player.fireBlasters();
      // player.update();

      // handleEdges(width, height) {
  //   if (this.x <= 0 || this.pos.x >= width) {
  //     // convert angle to velocity or direction,
  //     // flip x component
  //     // convert back to angle
  //     // thisad
  //   }
  // }



  // setVelocity(dir) {


  //   // Normalize direction vector then scale by player's max_speedd
  //   // this.vel = Util.scale(Util.norm(dir), this.max_speed);
  //   // let normDir = Util.dir(dir);
  //   // console.log('normDir',normDir);
  //   // this.vel = Util.scale(normDir, this.max_speed)
  //   // if (logCount <= 1) {
  //   //   console.log('setVel dir', dir);
  //   // }

  //   // if (logCount++ % logCon === 0)  {
  //   //   console.log('setVel this.vel', this.vel);
  //   //   console.log('setVel dir', dir);
  //   // }
  // }


  // // PROOF - THIS METHOD DOESN'T ACCOUNT FOR PROJECTILES GOING OFF BOTTOM LEFT / TOP RIGHT OF SCREEN
  // // PROOF - CONSIDER REWRITING THIS. OTHER MAP OBJECTS
  // isOutOfBounds(projectile) {
  //   return projectile.x <= -projectile.width + MAP_BORDER.WALL_PADDING &&
  //     projectile.y <= -projectile.height + MAP_BORDER.WALL_PADDING &&
  //     projectile.x >= DIM_X - MAP_BORDER.WALL_PADDING - projectile.width &&
  //     projectile.y >= DIM_Y - MAP_BORDER.WALL_PADDING - projectile.height;
  // }
